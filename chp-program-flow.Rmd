---
title:  
output:
  html_document:
    toc: false
bibliography: references.bib
nocite: |
  @NEON-surfwatertemp
---

```{r, include = FALSE, purl = FALSE}
# Functions and data
getwd()
source("src/setup.R")

# get chapter number based on name
.chp <- "program-flow"
.chp_num <- .get_chpNum("chp-program-flow", type = "fileName")
.chp_str <- ifelse(nchar(.chp_num) > 1, .chp_num, paste0("0", .chp_num))

# knitr options
source("src/knit-options.R")
.knitr_fig_path(paste0(.chp_str, "-"))

# Silently set seed for random number generation, so we don't have to explain it
set.seed(10)
```

# Chapter `r .chp_num`. `r .get_chpName(.chp_num, type.to = "nameLong")` {.tabset}

## Overview 

> Suppose you have temperature measurements collected over the course of a year from 100 different sensors, each saved in its own data file, and you want to summarize the daily temperature minima and maxima for each sensor, but only if the sensor did not malfunction. Wouldn't it be great if you had one code script that looks in a folder for the temperature sensor data files, detects whether the data are valid and if so, summarizes the data and saves this to an output file? 

This lesson will introduce you to a central idea in computer-programming- how to write flexible code that makes automated and repeated data-dependent decisions. The tools that we will use are common to most programming languages, even if the exact syntax varies. These fundamental elements of programming are called **conditionals** and **loops**.

### What we will learn

In this lesson 
`r .get_LO(.chp, .LOtable, prefix = TRUE)`


#### Key Terms & Commands

* if-then-else statements
* loops
* iteration
* boolean operators: `&` and `|`
* `if()`
* `else()`
* `ifelse()`
* `any()` and `all()`
* `for()`
* `while()`
* `print()`
* `paste()`
* `which()`


### Prerequisites

Before beginning this lesson you should have completed the lesson [`r .get_chpName("functions", type.from = "chp")`](chp-functions.html) and any prerequisites therein.

Before you begin:

1. Open the R-course-NEON-workbook RStudio project.
2. Create a new R script named `r paste0("lesson_", .chp_str, "_code.R")` in the lesson-code folder of the student workbook.
3. Whenever you see R code like this:

```{r eval = FALSE}
Type (or copy) this into your R script. Then run it in the Console.

```

4. Whenever you see a challenge like this:

:::{.challenge}

Try to solve the problem by writing R code into your script. Check your answer by clicking:

<details><summary>**Solution:**</summary>

::: {.solution}

```{r eval = FALSE}
The code that solves the challenge will appear here.
```

Along with an explanation.

:::

</details>

:::

<br>


4. Be sure to click **Save** often to save your work.


## Lesson

In this lesson we are going to download and work with surface water temperature data  [DP1.20053.001](https://data.neonscience.org/data-products/DP1.20053.001) from four NEON aquatic sites: Caribou Creek, Alaska (CARI), Martha Creek, Washington (MART), Teakettle Creek, California (TECR) and Sycamore Creek, Arizona (SYCA). You can see a map of these sites on the [NEON website](https://www.neonscience.org/field-sites/explore-field-sites).

Recall from the lesson [`r .get_chpName("functions", type.from = "chp")`](chp-functions.html) that we can download data from NEON using the `loadByProduct()` function in the `neonUtilities` package. We need to specify the product ID number, sites and dates for which we want data and then type `y` when prompted to download the data at the command line.

```{r eval = FALSE}
library(neonUtilities)

# Define dates for download: June 1 - Oct 31, 2021
# but we need to start before June 1 to get the entire month of June
startdate <- "2021-05-31"
enddate <- "2021-10-31"

# Define the sites to download 
# TECR = Teakettle Creek, SYCA = Sycamore Creek
# MART = Martha Creek, CARI = Caribou Creek
sites <- c("TECR", "SYCA", "MART", "CARI") 

# Define the data product
dpID <- "DP1.20053.001"  # Surface water temperature

# Temperature in surface water
watertemp <- loadByProduct(dpID = dpID,
                           site = sites,
                           startdate = startdate,
                           enddate = enddate)

```
```{r include = FALSE, message = FALSE}
# Load neonUtilities package
library(neonUtilities)

# Load previously downloaded object
#save(watertemp, file = "src/chp-program-flow_watertemp.RData")
load("src/chp-program-flow_watertemp.RData")
```

You should now have a new object named `watertemp` in the Environment panel. It should be a list with nine elements. Let's extract the list element of `watertemp` that contains the data and save it as a separate data frame.

```{r}
# Extract 30 min temperature averages from watertemp
# and save as a separate data frame
TSW_30min <- watertemp$TSW_30min

```

Now we have a data frame where each row summarizes temperature measurements over a 30 minute period from May - October, 2021 for the four sites from which we requested data (TECR, SYCA, MART, CARI).

The last thing we will do to get these data ready to work with is to convert the `startDateTime` column to a date-time class so that we can use it as an actual date. We will use the `ymd_hms()` function from the `lubridate()` package for this.

```{r message = FALSE}
# Load the lubridate package
library(lubridate)

# Convert startDateTime to a date-time class
TSW_30min$startDateTime <- ymd_hms(TSW_30min$startDateTime)

```
To get a quick summary of the data available, we can use the `table()` function to count the number of observations (e.g. rows) from each month and site. The code below uses the `with()` function to specify the dataframe that `table()` should use to find columns named `startDateTime` and `siteID`. 

```{r}
# Count the number of observations in each month and site
with(TSW_30min, table(months(startDateTime), siteID))

```
The `months()` function extracts the month from the `startDateTime` column as text. (`month()` would give the numeric month).


### Conditionals

A conditional statement executes different lines of code depending on whether or not a particular condition is true. This allows us to write code that performs different actions depending on the values contained in variables, ultimately defining the flow of a program.

There are several ways to control flow in R using conditionals. The most commonly used approaches are the constructs:

```{r, eval = FALSE}
# if
if (condition is true) {
  perform action
}

# if ... else
if (condition is true) {
  perform action
} else {  # that is, if the condition is false,
  perform alternative action
}
```

Say, for example, that we want the R console to print a message if a variable `x` has a particular value:

```{r}
x <- 8

if (x >= 10) {
  print("x is greater than or equal to 10")
}

x
```

The print statement does not appear in the console because x is not greater than 10. To print a different message for numbers less than 10, we can add an `else` statement.

```{r}
x <- 8

if (x >= 10) {
  print("x is greater than or equal to 10")
} else {
  print("x is less than 10")
}
```

You can also test multiple conditions by using `else if`.

```{r}
x <- 8

if (x >= 10) {
  print("x is greater than or equal to 10")
} else if (x > 5) {
  print("x is greater than 5, but less than 10")
} else {
  print("x is less than 5")
}
```

::: {.challenge}
Change the value of `x` to `3` (`x <- 3`), then re-run the conditional statement above to verify that this works.

What happens when you change the value of `x` to be missing (`NA`)?

:::


**Important:** when R evaluates the condition inside `if()` statements, it is looking for a logical data type, i.e., `TRUE` or `FALSE`. If the value inside the `if()` statement is anything but `TRUE` or `FALSE` (e.g. `NA`) the console will print an error message.




::: {.challenge}

The `finalQF` column in `TSW_30min` indicates whether the data are valid to use. It will be `0` when the data are good and `1` when the data could be erroneous.

Use an `if()` statement to print a message that says whether there are any erroneous data points in `TSW_30min`.

<details><summary>**Solution:**</summary>

::: {.solution}

There are lots of ways to solve this problem. Here's one way to solve this problem using commands you already know.

```{r eval = FALSE}
# First we subset TSW_30min to only contain rows where finalQF is 1
bad_data <- subset(TSW_30min, finalQF == 1)

# Next we count the number of rows
N_bad <- nrow(bad_data)

# Then we use a conditional to print a message
# depending on the number of rows of bad data
if (N_bad > 0) {
 print("This data contains erroneous measurements.") 
}


```

:::

</details>

:::

<br>


When you tried the challenge above, did you try something like this and get a warning message?

```{r}
if (TSW_30min$finalQF == 1) {
  print("This data contains erroneous measurements.")
}
```

The `if()` function only accepts singular (of length 1) inputs, and therefore returns an error when you use it with a vector. The `if()` function will still run, but will only evaluate the condition in the first element of the vector. Therefore, to use the `if()` function, you need to make sure your input is
singular (of length 1).

To determine whether some or all of the elements of a vector are equal to a particular value, you can use the `any()` and `all()` functions. 

`any()` tests whether any of the elements in a vector are `TRUE` and returns a single value of `TRUE` if at least one element is `TRUE`. In contrast the `all()` function tests whether all of the elements of a vector are `TRUE` and only returns the value `TRUE` if this is the case.

```{r}
all_F <- c(FALSE, FALSE, FALSE)
some_T <- c(TRUE, FALSE, TRUE)
all_T <- c(TRUE, TRUE, TRUE)

any(all_F)
any(some_T)
any(all_T)

all(some_T)
all(all_T)
```

Here is a more efficient way to solve the last challenge using the `any()` function. 

```{r}
if (any(TSW_30min$finalQF ==  1)) {
 print("This data contains erroneous measurements.") 
}
```


#### Conditionals on vectors

If you need to condition across the elements of a vector, use the the `ifelse()` function. This function accepts both singular and vector inputs and is structured as follows:

```{r, eval = FALSE}
# ifelse function
ifelse(condition is true, perform action, perform alternative action)

```

where the first argument is the condition or a set of conditions to be met, the second argument is the statement that is evaluated when the condition is `TRUE`, and the third statement  is the statement that is evaluated when the condition is `FALSE`.

This function will return a vector the same length as what was supplied to the first argument.

```{r}
y <- -3
ifelse(y < 0, "y is a negative number", "y is not a negative number")

```

```{r}
y <- -2:3

ifelse(y < 0, "y is a negative number", "y is not a negative number")

```
The `ifelse()` function is particularly useful for creating a factor from numeric data or combining levels of a factor.

For example, we could create a factor in the `TSW_30min` data that identifies whether a site is in Alaska or the contiguous US (the "lower 48"):

```{r}
# Create a factor that identifies whether a site is in Alaska
# e.g. the CARI site
TSW_30min$siteLocation <- factor(ifelse(TSW_30min$siteID == "CARI", "AK", "lower48"))

```

::: {.challenge}

Create a new variable in `TSW_30min` named `frozen` that has the value `"above 0"` if the minimum temperature for an observation is greater than `0` and "below 0" if the minimum temperature is less than or equal to `0`.

Hint: use the `ifelse()` function on the `surfWaterTempMinimum` column.

<details><summary>**Solution:**</summary>

::: {.solution}

```{r}
TSW_30min$frozen <- ifelse(TSW_30min$surfWaterTempMinimum > 0, "above 0", "below 0")

```

We can use the `table()` function to see how many times each of these conditions occurred in these data.

```{r}
table(TSW_30min$frozen)
```

:::

</details>

:::

<br>





### Loops

**Loops** are a fundamental element of programming that allow you to repeat a set of actions multiple times. There are two main types:

* a `for` loop **iterates** over a set of elements, repeating the set of actions once for each element in the order that they are provided.
* a `while` loop repeats a set of actions over and over until a specific condition is met.

#### `for()` loops

The basic structure of a `for()` loop is:

```{r, eval = FALSE}
for (iterator in set of values) {
  do a thing
}
```

For example:

```{r}
for (i in 1:10) {
  print(i)
}
```

The `1:10` creates a vector of the integers `1` through `10`. Each time through the loop, the value of the object `i` will take on the next value in this vector. You can iterate over any other vector using any variable name:

```{r}
mypets <- c("cat", "dog", "bird", "cat")

for (animal in mypets) {
  print(animal)
}

```

We can use a `for()` loop nested within another `for()` loop to iterate over two things at
once.

```{r}
for (i in 1:5) {
  for (j in c('a', 'b', 'c', 'd', 'e')) {
    
    # The `paste()` function creates a character vector by 
    # concatenating the vectors `i` and `j`
    print(paste(i,j))
  }
}
```


We notice in the output that when the first index (`i`) is set to 1, the second index (`j`) iterates through its full set of indices. Once the indices of `j` have been iterated through, then `i` is incremented. This process continues until the last index has been used for each `for()` loop.

Rather than printing the results, we could write the loop output to an output object, in this case a matrix.

```{r}
output_vector <- vector()
for (i in 1:5) {
  
  for (j in c('a', 'b', 'c', 'd', 'e')) {
    # save the result to a temporary variable temp_output
    temp_output <- paste(i, j)
    
    # add temp_output to the end of output_vector
    output_vector <- c(output_vector, temp_output)
  }
  
}

output_vector
```

This approach can be useful, but 'growing your results' (building the result object incrementally) is computationally inefficient, so avoid it when you are iterating through a lot of values.

::: {.callout-tip}
Don't grow your results

One of the biggest things that trips up novices and experienced R users alike, is building a results object (vector, list, matrix, data frame) as your for loop progresses. Computers are very bad at handling this, so your calculations can very quickly slow to a crawl. It is much better to define an empty results object before hand of appropriate dimensions, rather than initializing an empty object without dimensions. In most cases you will know how many output elements a loop will produce and can therefore determine how many elements, rows or columns the output object needs to have.

:::

In the example above, we know that there should be `5 x 5 = 25` results. A better way to save the output would be to create an empty matrix with 5 rows and 5 columns, then at each iteration store the results in the appropriate location.

For this example, the following is much more efficient.

```{r}
# Create an empty output object for saving results
output_matrix <- matrix(nrow = 5, ncol = 5)

# Define the values needed in the second for loop
j_vector <- c('a', 'b', 'c', 'd', 'e')

# Iterate over the numbers 1 - 5
for (i in 1:5) {
  
  # Iterate over the numbers 1 - 5
  for (j in 1:5) {
    
    # Select the corresponding letter
    temp_j_value <- j_vector[j]
    
    # Save the result to a temporary variable
    temp_output <- paste(i, temp_j_value)
    
    # Save the temporary variable to the appropriate
    # location in the output matrix
    output_matrix[i, j] <- temp_output
  }
}

output_matrix
```

In general, the advice of many `R` users would be to learn about `for()` loops, but to avoid using `for()` loops unless the order of iteration is important: i.e. the calculation at each iteration depends on the results of previous iterations. If the order of iteration is not important, then you should try to use **vectorization** (see lessons [`r .get_chpName("functions", type.from = "chp")`](chp-functions.html) and [`r .get_chpName("tidyverse", type.from = "chp")`](chp-tidyverse.html).



::: {.challenge}

In the lesson [`r .get_chpName("functions", type.from = "chp")`](chp-functions.html) we wrote a function that calculates the average monthly surface water temperature for a particular month at a particular site.

It looks like this and you should have saved it in a script called `functions.R` in the `src` folder.

```{r}
# A function that calculates average monthly surface water temperature
# across both sensors at a NEON site from a dataframe of temperature
# measurements.
# Arguments:
#   dat = a dataframe containing the columns: 
#         surfWaterTempMean, startDateTime, siteID, finalQF
#   site = the NEON site code for the site of interest
#   month = the month to calculate average temperature over
#   na.rm = indicates whether NA values should be removed prior to calculation
calc_monthly_avg <- function(dat, site, month, na.rm = TRUE) {
  
  # Remove data that did not pass quality control
  # keep finalQF == 0
  keep_dat <- subset(dat, finalQF == 0)
  
  # Subset the data frame to only contain observations from site
  keep_dat <- subset(keep_dat, siteID == site)
  
  # Subset the data frame to only contain observations from month
  # convert character to date
  keep_dat$startDateTime <- lubridate::ymd_hms(keep_dat$startDateTime) 
  
  # extract month as a numeric value
  keep_dat$startMonth <- lubridate::month(keep_dat$startDateTime)
  
  # subset based on month
  keep_dat <- subset(keep_dat, startMonth == month)
  
  # Calculate the average of the surfWaterTempMean column
  # use the na.rm value provided by the user of the function
  vals <- mean(keep_dat$surfWaterTempMean, na.rm = na.rm)
  
  # Return the calculated value
  return(vals)
}
```

Load this function into your current R session by either running the code above or sourcing the `functions.R` script:

```{r eval = FALSE}
source("src/functions.R")
```

```{r include = FALSE}
source("src/functions_chp-functions.R")
```

Using this function, write a loop that calculates the average monthly temperature at the Teakettle Creek site (`siteID == "TECR"`) in each month in the `TWS_30min` data.

The loop should save the output to a vector.


<details><summary>**Solution:**</summary>

::: {.solution}

```{r}
# Define vector of months to iterate over
# and save the length of this vector
use_months <- 6:10
N_months <- length(use_months)

# Define an empty vector for saving the data
# that is the same length as use_months
mean_temp <- rep(NA, N_months)

# Loop across months
for (i in 1:N_months) {
  
  # Define the month for this iteration
  this_month <- use_months[i]
    
  # Calculate monthly mean temp
  # and save into the vector
  mean_temp[i] <- calc_monthly_avg(dat = TSW_30min, 
                                site = "TECR",
                                month = this_month) 
  
}
 

# Print the output
mean_temp

```

:::

</details>

:::

<br>




::: {.challenge}

Update your solution to the prior challenge to write a set of nested loops that calculate the average water temperature for each month at each site in `TSW_30min`. The loop should save the output to a matrix.

<details><summary>**Solution:**</summary>

::: {.solution}

```{r}
# Define vector of months to iterate over
# and save the length of this vector
use_months <- 6:10
N_months <- length(use_months)

# Define vector of sites to iterate over
# and save the length of this vector
use_sites <- unique(TSW_30min$siteID)
N_sites <- length(use_sites)

# Define a matrix for saving values:
# months will be the rows and sitess with be the columns
mean_temp <- matrix(NA, nrow = N_months, ncol = N_sites)

# Loop across months
for (i in 1:N_months) {
  
  # Define the month for this iteration
  this_month <- use_months[i]
 
  # Loop across sites
  for (j in 1:N_sites) {
    
    # Define the site for this iteration
    this_site <- use_sites[j]
    
    # Calculate monthly mean temp
    # and store in the matrix
    mean_temp[i, j] <- calc_monthly_avg(dat = TSW_30min, 
                     site = this_site,
                     month = this_month) 
    
  }
  
}

# Print the output
mean_temp

```
After the calculation in the loop, we could make the output more informative by assigning column or row names:

```{r}
colnames(mean_temp) <- use_sites
rownames(mean_temp) <- use_months

mean_temp

```

Or, by converting it to a dataframe with a column for site.

```{r}
mean_temp <- data.frame(month = use_months, mean_temp)
mean_temp
```

:::

</details>

:::

<br>




#### `while()` loops

Sometimes you will find yourself needing to repeat an operation as long as a certain condition is met. You can do this with a `while()` loop.

```{r, eval=FALSE}
while (this condition is true) {
   do a thing
}
```

Here is an example of a `while` loop that adds up the integers until it reaches a sum that is greater than or equal to 100.

```{r collapse = TRUE}
# Define the initial condition:
i <- 1
total <- i

# Repeat the loop while the value of total < 100.
while (total < 100) {
  
  # Increment the integer by 1 and add to the total
  i <- i + 1
  total <- total + i
  
}

# print the total and value of i when the loop stopped
total
i

```


`while()` loops will not always be appropriate. You have to be particularly careful that you don't end up stuck in an infinite loop because the condition is always met and hence the while statement never terminates. If you do end up in an infinite loop, you can cancel the operation running in the console by typing <kbd>ESC</kbd> or clicking the red stop sign in the upper right corner of the console window.



::: {.challenge}

Write a `while` loop that prints out the difference between the maximum and minimum temperature values for each row of `TSW_30min` until the temperature difference exceeds 5 degrees. This means that temperature fluctuated more than 5 degrees in that 30 minute time period. Your loop should also print out the row number.

<details><summary>**Solution:**</summary>

::: {.solution}

```{r eval = FALSE}
# Start at row 1
i <- 1

# Calculate the temperature difference in row i
temp_diff <- with(TSW_30min[i, ], surfWaterTempMaximum - surfWaterTempMinimum)

# Repeat the loop until the difference is greater than 5
while(temp_diff <= 5){
  
  # Print the temperature difference and the row number
  print(paste("row:", i, "difference:", temp_diff))
  
  # Increment the row by 1 and recalculate the difference
  i <- i + 1
  temp_diff <- with(TSW_30min[i, ], surfWaterTempMaximum - surfWaterTempMinimum)
  
}


```


:::

</details>

:::

<br>

While loops are rarely the best solution to a problem. Here is a more efficient way to identify the first time a row exceeds a five degree difference between the maximum and minimum temperature values.

To do this we use the `which()` function. This function gives the indices of a boolean vector that are true.

```{r}
which(c(TRUE, TRUE, FALSE, TRUE))

which(20:30 > 27)

which(c("a", "b", "c", "d") %in% c("c", "a"))

```
We can use `which()` to find the first index of a row with a temperature difference greater than 5 degrees, then calculate the temperature difference from all rows less than this index.

```{r}
# Calculate the difference in temperatures
tempdiff <- with(TSW_30min, surfWaterTempMaximum - surfWaterTempMinimum)

# Which rows of TSW_30min have a temperature range >= 5?
gt5 <- which(tempdiff >= 5)

# What is the smallest index in gt5?
first_gt5 <- min(gt5)

# Return the temperature difference for all rows preceding first_gt5
tempdiff[1:(first_gt5-1)]
```
You could even return this result as a dataframe:

```{r}
data.frame(row = 1:(first_gt5-1), 
           temp_difference = tempdiff[1:(first_gt5-1)])

```




### Putting it all together

We're going to write a script that plots the average monthly temperature for each NEON site in `TSW_30min`, but only if less than 10% of the data are erroneous. Our script will automatically save each plot to a file in an output folder.

We should start by creating a new R script with a descriptive name and saving it in the `src` folder. Create a new R script in your `src` folder named `plot_monthly_temp.R`. In this script use comments to outlines what we are trying to do:

```{r eval= FALSE}

# Define vector of months in TSW_30min

# Define vector of sites in TSW_30min

# Define a matrix for saving values


# Loop through each month in TSW_30min
for (     ) {
  
  # Loop through each site in TSW_30 min
  for (    ) {

      # Determine the fraction of erroneous data
      # finalQF != 0
  
      # If the fraction is < 0.1
      # Calculate the monthly mean temperature
    
      # Save values into the matrix

  
  }
  
}

# Convert the matrix into a dataframe

# For each site
# Plot monthly mean temperature versus month

# Save the plot to a file in the results folder


```

We have already done most of this. The code below aggregates code we have already written in the lesson above.

```{r eval= FALSE}
# Source our functions script that contains the 
# calc_monthly_avg() function
source("src/functions.R")

# Define vector of months in TSW_30min
use_months <- unique(month(TSW_30min$startDateTime))
N_months <- length(use_months)

# Define vector of sites in TSW_30min
use_sites <- unique(TSW_30min$siteID)
N_sites <- length(use_sites)

# Define a matrix for saving values:
# months will be the rows and sitess with be the columns
mean_temp <- matrix(NA, nrow = N_months, ncol = N_sites)

# Loop through each month in TSW_30min
for (i in 1:N_months) {
  
  # Define this month
  this_month <- use_months[i]
  
  # Loop through each site in TSW_30 min
  for (j in 1:N_sites) {
    
      # Define this site
      this_site <- use_sites[j]
    
      # Determine the fraction of erroneous data
      # finalQF != 0
      
      
  
      # If the fraction is < 0.1
      # Calculate the monthly mean temperature
      this_temp <- calc_monthly_avg(dat = TSW_30min, 
                     site = this_site,
                     month = this_month) 
      
    
      # Save values into the matrix
      mean_temp[i, j] <- this_temp
    
  }
  
}

# Convert the matrix into a dataframe

# For each site
# Plot monthly mean temperature versus month

# Save the plot to a file in the results folder

```

All we need to do is determine the percentage of erroneous data in each month and site. There are several approaches to doing this:

1. We could subset `TSW_30min` inside the two loops and then look for erroneous data in each subset.
2. We could tabulate the number of erroneous data points in each month and site before using the loop, then select the appropriate element from this table inside the loop.

We should select the option that requires the least number of computations. This would be option 2, because it doesn't require subsetting the data `r N_months*N_sites` times (`N_months x N_sites`). Let's see how this works:

```{r}
# Tabulate TSW_30min by month, site and value of finalQF
QF_tab <- with(TSW_30min, table(month(startDateTime), siteID, finalQF))

dim(QF_tab)
dimnames(QF_tab)
```
We can see that QF_tab is a 3-dimensional array because we tabulated by 3 variables. The first dimension is the month, the second dimension is the site and the third dimension is the value of `finalQF`. We can see the values stores in the array here:

```{r}
QF_tab
```
Thus if we specify an index in the third dimension we can select either the number of good or erroneous data points:

```{r}
# Number of good data points
QF_tab[ , , 1]

# Number of erroneous data points
QF_tab[ , , 2]

```


::: {.challenge}

Use mathematical operations on QF_tab to make a table containing the fraction of erroneous data points for each site and month ( = num erroneous points / total number of points). Remember that arithmetic on vectors, matrices and array occurs element-wise.


<details><summary>**Solution:**</summary>

::: {.solution}

```{r}
# Calculate the fraction of erroneous data points
QF_frac <- QF_tab[ , , 2] / (QF_tab[ , , 1] + QF_tab[ , , 2])

```

:::

</details>

:::

<br>

Now if we calculate this table containing the fraction of erroneous data points before the loop, we can select elements from it within the loop to decide whether to proceed with calculating mean temperature in a given month and site.

```{r echo = FALSE}
QF_frac
```

We need to be careful to use names (e.g. "6") rather than numeric indices to select the row and column from `QF_frac`, since the order of rows and columns is not necessarily the same as the order in `use_months` and `use_sites`.

```{r}
QF_frac["6", "CARI"]

```
That means that we need to convert `use_month` to a character before using it to select a row from `QF_frac`. Otherwise, this will happen:

```{r}
QF_frac[6, "CARI"]
```

Here's our code so far:

```{r eval = FALSE}
# Source our functions script that contains the 
# calc_monthly_avg() function
source("src/functions.R")

# Define vector of months in TSW_30min
use_months <- unique(month(TSW_30min$startDateTime))
N_months <- length(use_months)

# Define vector of sites in TSW_30min
use_sites <- unique(TSW_30min$siteID)
N_sites <- length(use_sites)

# Define a matrix for saving values:
# months will be the rows and sitess with be the columns
mean_temp <- matrix(NA, nrow = N_months, ncol = N_sites)

# Tabulate TSW_30min by month, site and value of finalQF
#  and calculate the fraction of erroneous data points
QF_tab <- with(TSW_30min, table(month(startDateTime), siteID, finalQF))
QF_frac <- QF_tab[ , , 2] / (QF_tab[ , , 1] + QF_tab[ , , 2])

# Loop through each month in TSW_30min
for (i in 1:N_months) {
  
  # Define this month
  this_month <- use_months[i]
  
  # Loop through each site in TSW_30 min
  for (j in 1:N_sites) {
    
      # Define this site
      this_site <- use_sites[j]
    
      # Determine the fraction of erroneous data
      this_frac <- QF_frac[as.character(this_month), this_site]
      
      
      # If the fraction is < 0.1
      if (this_frac < 0.1) {
        
        # Calculate the monthly mean temperature
        this_temp <- calc_monthly_avg(dat = TSW_30min, 
                       site = this_site,
                       month = this_month) 
      
        # Save values into the matrix
        mean_temp[i, j] <- this_temp
        
      } # else the NA value will stay in the matrix
 
  }
  
}

# Define dimension names for mean_temp based on
# the order of months and sites in use_months and use_sites
rownames(mean_temp) <- use_months
colnames(mean_temp) <- use_sites

# Convert the matrix into a dataframe

# For each site
# Plot monthly mean temperature versus month

# Save the plot to a file in the results folder
```

```{r echo = FALSE}
# Define vector of months in TSW_30min
use_months <- unique(month(TSW_30min$startDateTime))
N_months <- length(use_months)

# Define vector of sites in TSW_30min
use_sites <- unique(TSW_30min$siteID)
N_sites <- length(use_sites)

# Define a matrix for saving values:
# months will be the rows and sitess with be the columns
mean_temp <- matrix(NA, nrow = N_months, ncol = N_sites)

# Tabulate TSW_30min by month, site and value of finalQF
#  and calculate the fraction of erroneous data points
QF_tab <- with(TSW_30min, table(month(startDateTime), siteID, finalQF))
QF_frac <- QF_tab[ , , 2] / (QF_tab[ , , 1] + QF_tab[ , , 2])

# Loop through each month in TSW_30min
for (i in 1:N_months) {
  
  # Define this month
  this_month <- use_months[i]
  
  # Loop through each site in TSW_30 min
  for (j in 1:N_sites) {
    
      # Define this site
      this_site <- use_sites[j]
    
      # Determine the fraction of erroneous data
      this_frac <- QF_frac[as.character(this_month), this_site]
      
      
      # If the fraction is < 0.1
      if (this_frac < 0.1) {
        
        # Calculate the monthly mean temperature
        this_temp <- calc_monthly_avg(dat = TSW_30min, 
                       site = this_site,
                       month = this_month) 
      
        # Save values into the matrix
        mean_temp[i, j] <- this_temp
        
      } # else the NA value will stay in the matrix
 
  }
  
}

# Define dimension names for mean_temp based on
# the order of months and sites in use_months and use_sites
rownames(mean_temp) <- use_months
colnames(mean_temp) <- use_sites

```

This code will run, but isn't plotting a figure yet. We can check the values calculated in the loop for mean temperature and see that the ones where `QF_frac` were greater than `0.1` remained as missing (`NA`).

```{r}
mean_temp

QF_frac
```

The last step is to create a plot and save it to a file for each site. We will use the `plot()` function in base R for this. Recall that for the `plot()` function we need to supply arguments `x` and `y` that each contain a vector of values that the function will use to create a scatter plot.

::: {.challenge}

Fill in the three blanks in the code below so that it will execute properly. This code should create a graph of mean monthly temperature for each site and save that graph as a file with the name of the site in the file name.

```{r eval = FALSE}
# Convert the matrix into a dataframe
mean_temp_df <- data.frame(month = use_months, mean_temp)

# For each site
for (this_site in use_sites) {
  
  # Define the file name for this plot using the site in this iteration
  this_filename <- paste("results/mean_monthly_temp_", ___________,".pdf", sep = "")
  
  # Open a new graphics device to save the plot
  pdf(this_filename, height = 5, width = 4)
  
  # Plot monthly mean temperature versus month
  plot(x = ___________, 
       y = mean_temp_df[, _________],
       xlab = "Month", 
       ylab = expression("Mean temperature"~(degree*C)))
  
  # Close the graphics device (save the plot file)
  dev.off()
  
}
```

Once you solve this challenge, append this code to the end of your script.

:::

<br>


<details><summary>Click here to show what your final script should look like.</summary>

```{r eval = FALSE}
# Source our functions script that contains the 
# calc_monthly_avg() function
source("src/functions.R")

# Define vector of months in TSW_30min
use_months <- unique(month(TSW_30min$startDateTime))
N_months <- length(use_months)

# Define vector of sites in TSW_30min
use_sites <- unique(TSW_30min$siteID)
N_sites <- length(use_sites)

# Define a matrix for saving values:
# months will be the rows and sitess with be the columns
mean_temp <- matrix(NA, nrow = N_months, ncol = N_sites)

# Tabulate TSW_30min by month, site and value of finalQF
#  and calculate the fraction of erroneous data points
QF_tab <- with(TSW_30min, table(month(startDateTime), siteID, finalQF))
QF_frac <- QF_tab[ , , 2] / (QF_tab[ , , 1] + QF_tab[ , , 2])

# Loop through each month in TSW_30min
for (i in 1:N_months) {
  
  # Define this month
  this_month <- use_months[i]
  
  # Loop through each site in TSW_30 min
  for (j in 1:N_sites) {
    
      # Define this site
      this_site <- use_sites[j]
    
      # Determine the fraction of erroneous data
      this_frac <- QF_frac[as.character(this_month), this_site]
      
      
      # If the fraction is < 0.1
      if (this_frac < 0.1) {
        
        # Calculate the monthly mean temperature
        this_temp <- calc_monthly_avg(dat = TSW_30min, 
                       site = this_site,
                       month = this_month) 
      
        # Save values into the matrix
        mean_temp[i, j] <- this_temp
        
      } # else the NA value will stay in the matrix
 
  }
  
}

# Define dimension names for mean_temp based on
# the order of months and sites in use_months and use_sites
rownames(mean_temp) <- use_months
colnames(mean_temp) <- use_sites

# Convert the matrix into a dataframe
mean_temp_df <- data.frame(month = use_months, mean_temp)

# For each site
for (this_site in use_sites) {
  
  # Define the file name for this plot
  this_filename <- paste("results/mean_monthly_temp_", this_site,".pdf", sep = "")
  
  # Open a new graphics device to save the plot
  pdf(this_filename, height = 5, width = 4)
  
  # Plot monthly mean temperature versus month
  plot(x = mean_temp_df$month, 
       y = mean_temp_df[, this_site],
       xlab = "Month", 
       ylab = expression("Mean temperature"~(degree*C)))
  
  # Close the graphics device (save the plot file)
  dev.off()
  
}

```

</details>



## Exercises

After completing these exercises, learners will be able to 
`r .get_LO(.chp, .CStable, prefix = TRUE, bullet = "1.")`

Save each of these exercises in a new R script named with the exercise number.

**`r .chp_num`.1** 

Use the `ifelse()` function on the `TSW_30min` data frame to create a factor with two levels that records the temperature difference between the maximum and minimum temperature values for each row as follows:

|                 low: $\le$ 0.5 &deg;C difference

|                 high: $>$ 0.5 &deg;C difference

<br>

Create a table showing the number of observations from each site that occur at each level of this factor. 

Your code should produce this output:

```{r echo = FALSE}

TSW_30min$temp_diff <- with(TSW_30min, surfWaterTempMaximum - surfWaterTempMinimum)
TSW_30min$temp_diff_fact <- ifelse(TSW_30min$temp_diff <= 0.5, "low", "high")
TSW_30min$temp_diff_fact <- factor(TSW_30min$temp_diff_fact, levels = c("low", "high"))

with(TSW_30min, table(temp_diff_fact, siteID))

```

**`r .chp_num`.2** 

Use the `ifelse()` function on the `TSW_30min` data frame to create a factor with three levels that records the temperature difference between then maximum and minimum temperature values for each row as follows:

|                 low: $\le$ 0.5 &deg;C difference

|                 medium: $>$ 0.5 &deg;C and $\le$ 2 &deg;C difference

|                 high: $>$ 2 &deg;C difference

<br>

Create a table showing the number of observations from each site and month that occur at each level of this factor. 

Your code should produce this output:

```{r echo = FALSE}

TSW_30min$temp_diff <- with(TSW_30min, surfWaterTempMaximum - surfWaterTempMinimum)
TSW_30min$temp_diff_fact <- ifelse(TSW_30min$temp_diff <= 0.5, "low",
                                   ifelse(TSW_30min$temp_diff <= 2, "medium", "high"))
TSW_30min$temp_diff_fact <- factor(TSW_30min$temp_diff_fact, levels = c("low", "medium", "high"))

with(TSW_30min, table(month(startDateTime), temp_diff_fact, siteID))

```

**`r .chp_num`.3** 

Write a `for()` loop that iterates over the sites in `TSW_30min` and prints the number of erroneous data points. The loop should print both the site name and the number of rows with `finalQF == 1`, like this:

```{r echo = FALSE}
QF_tab <- with(TSW_30min, table(siteID, finalQF))

for(i in unique(TSW_30min$siteID)){
  
   print(paste("Site", i, "has", QF_tab[i, "1"], "bad data points."))
  
}

```

**`r .chp_num`.4** 

Solve exercise `r .chp_num`.3 without subsetting `TSW_30min` inside the for loop.

**`r .chp_num`.5** 

Each row of `TSW_30min` aggregates 30 minutes of data from a sensor that collects temperature measurements once per second. This means that there should be `60 x 30 = 1800` measurements used for each row in this data frame. The number of measurements actually used is recorded in the `surfWaterTempNumPts` column. 

A. Fill in the blanks in the code below to write a `while()` loop that finds the first row of `TSW_30min` where fewer than 1800 measurements were used. The loop should print out only the number of the first row where this occurs and not all of the preceeding rows. 

```{r eval = FALSE}
i <- 1

while ( _________  == 1800 ) {
  
  i <- ____________
  
  if ( _______________ ) {
    
    print( ______________ )
    
  }
  
}


```

```{r echo = FALSE}
i <- 1

while (TSW_30min[i, "surfWaterTempNumPts"] == 1800) {
  
  i <- i + 1
  
  if (TSW_30min[i, "surfWaterTempNumPts"] != 1800) {
    print(i)
  }
  
}


```

B. Write code that gives the same output as above without using a `while()` loop.

```{r include = FALSE}

min(which(TSW_30min$surfWaterTempNumPts != 1800))


```



<br>

The following questions involve modifying the `calc_monthly_avg()` from the [`r .get_chpName("functions", type.from = "chp")`](chp-functions.html) lesson. The code of this function is below. Copy it into your R script and modify it as directed. Verify that your new function works using the `TSW_30min` data frame from this lesson.

```{r eval = FALSE}
# A function that calculates average monthly surface water temperature
# across both sensors at a NEON site from a dataframe of temperature
# measurements.
# Arguments:
#   dat = a dataframe containing the columns: 
#         surfWaterTempMean, startDateTime, siteID, finalQF
#   site = the NEON site code for the site of interest
#   month = the month to calculate average temperature over
#   na.rm = indicates whether NA values should be removed prior to calculation
calc_monthly_avg <- function(dat, site, month, na.rm = TRUE) {
  
  # Remove data that did not pass quality control
  # keep finalQF == 0
  keep_dat <- subset(dat, finalQF == 0)
  
  # Subset the data frame to only contain observations from site
  keep_dat <- subset(keep_dat, siteID == site)
  
  # Subset the data frame to only contain observations from month
  # convert character to date
  keep_dat$startDateTime <- lubridate::ymd_hms(keep_dat$startDateTime) 
  
  # extract month as a numeric value
  keep_dat$startMonth <- lubridate::month(keep_dat$startDateTime)
  
  # subset based on month
  keep_dat <- subset(keep_dat, startMonth == month)
  
  # Calculate the average of the surfWaterTempMean column
  # use the na.rm value provided by the user of the function
  vals <- mean(keep_dat$surfWaterTempMean, na.rm = na.rm)
  
  # Return the calculated value
  return(vals)
}

```

**`r .chp_num`.6** 

Modify the `calc_monthly_avg()` function to return temperature values in fahrenheit or kelvin, based on an argument provided to the function. By default the function should return values in Celsius. 

HINT: Use a conditional statement.

```{r include = FALSE}
calc_monthly_avg <- function(dat, site, month, units = "C", na.rm = TRUE) {
  
  # Remove data that did not pass quality control
  # keep finalQF == 0
  keep_dat <- subset(dat, finalQF == 0)
  
  # Subset the data frame to only contain observations from site
  keep_dat <- subset(keep_dat, siteID == site)
  
  # Subset the data frame to only contain observations from month
  # convert character to date
  keep_dat$startDateTime <- lubridate::ymd_hms(keep_dat$startDateTime) 
  
  # extract month as a numeric value
  keep_dat$startMonth <- lubridate::month(keep_dat$startDateTime)
  
  # subset based on month
  keep_dat <- subset(keep_dat, startMonth == month)
  
  # Calculate the average of the surfWaterTempMean column
  # use the na.rm value provided by the user of the function
  vals <- mean(keep_dat$surfWaterTempMean, na.rm = na.rm)
  
  # Convert to Kelvin or Fahrenheit
  if (units == "F") {
    
    vals <- vals * (9/5) + 32
      
  } else if (units == "K") {
    
    vals <- vals + 273.15
    
  }
  
  # Return the calculated value
  return(vals)
}

```


**`r .chp_num`.7** 

Create a new function `calc_monthly_summary()` based on the `calc_monthly_avg()` function that will return the the max, min or mean temperature values for a given month and site, based on an argument provided to the function. By default the function should return the mean values.  

HINT: Use a conditional statement.

```{r include = FALSE}
calc_monthly_summary <- function(dat, site, month, stat = "mean", na.rm = TRUE) {
  
  # Remove data that did not pass quality control
  # keep finalQF == 0
  keep_dat <- subset(dat, finalQF == 0)
  
  # Subset the data frame to only contain observations from site
  keep_dat <- subset(keep_dat, siteID == site)
  
  # Subset the data frame to only contain observations from month
  # convert character to date
  keep_dat$startDateTime <- lubridate::ymd_hms(keep_dat$startDateTime) 
  
  # extract month as a numeric value
  keep_dat$startMonth <- lubridate::month(keep_dat$startDateTime)
  
  # subset based on month
  keep_dat <- subset(keep_dat, startMonth == month)
  
  # Convert to Kelvin or Fahrenheit
  if (stat == "min") {
    
    # Calculate the average of the surfWaterTempMean column
    # use the na.rm value provided by the user of the function
    vals <- min(keep_dat$surfWaterTempMean, na.rm = na.rm)
      
  } else if (stat == "max") {
    
    # Calculate the average of the surfWaterTempMean column
    # use the na.rm value provided by the user of the function
    vals <- max(keep_dat$surfWaterTempMean, na.rm = na.rm)
    
  } else if (stat == "mean") {
    
    # Calculate the average of the surfWaterTempMean column
    # use the na.rm value provided by the user of the function
    vals <- mean(keep_dat$surfWaterTempMean, na.rm = na.rm)
    
  }
  
  # Calculate the average of the surfWaterTempMean column
  # use the na.rm value provided by the user of the function
  vals <- mean(keep_dat$surfWaterTempMean, na.rm = na.rm)
  
  # Return the calculated value
  return(vals)
}

```

**`r .chp_num`.8** 

Modify the `calc_monthly_avg()` function so that the user can specify an argument for which sensors the average should be calculated from: "upper" (corresponding to horizontal position 101 or 111), "lower" (corresponding to horizontal position 102 or 112) or "both" (aggregating data from both sensors). The default value should be "both".

HINT: Use a conditional statement.

```{r include = FALSE}
calc_monthly_summary <- function(dat, site, month, sensor = "both", na.rm = TRUE) {
  
  # Remove data that did not pass quality control
  # keep finalQF == 0
  keep_dat <- subset(dat, finalQF == 0)
  
  # Subset the data frame to only contain observations from site
  keep_dat <- subset(keep_dat, siteID == site)
  
  # Subset the data frame to only contain observations from month
  # convert character to date
  keep_dat$startDateTime <- lubridate::ymd_hms(keep_dat$startDateTime) 
  
  # extract month as a numeric value
  keep_dat$startMonth <- lubridate::month(keep_dat$startDateTime)
  
  # subset based on month
  keep_dat <- subset(keep_dat, startMonth == month)
  
  # Convert to Kelvin or Fahrenheit
  if (sensor == "lower") {
    
    # Subset to the lower sensor
    keep_dat <- subset(keep_dat, horizontalPosition %in% c(101, 111))
      
  } else if (sensor == "upper") {
    
    # Subset to the upper sensor
    keep_dat <- subset(keep_dat, horizontalPosition %in% c(102, 112))
    
  } 
  
  # Calculate the average of the surfWaterTempMean column
  # use the na.rm value provided by the user of the function
  vals <- mean(keep_dat$surfWaterTempMean, na.rm = na.rm)
  
  # Return the calculated value
  return(vals)
}

```



## Sources and Resources

This lesson was adapted from [@swc-reproducible-lesson](https://swcarpentry.github.io/r-novice-gapminder/) episodes 7 and 10  by Jes Coyle.

<!-- ### Additional Resources -->

### Cited References

::: {#refs}
:::
