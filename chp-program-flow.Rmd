---
title:  
output:
  html_document:
    code_folding: show
    toc: false
bibliography: references.bib
---


```{r, include = FALSE, purl = FALSE}
# Functions and data
source("src/setup.R")

# get chapter number based on name
chp_num <- get_chpNum("chp-program-flow", type = "fileName")
chp_str <- ifelse(nchar(chp_num) > 1, chp_num, paste0("0", chp_num))

# knitr options
source("src/knit-options.R")
knitr_fig_path(paste0(chp_str, "-"))

# Silently load in the data for this lesson
gapminder <- read.csv("data/gapminder_data.csv", header = TRUE)

# Silently set seed for random number generation, so we don't have to explain it
set.seed(10)
```


Now that we've begun to appreciate how writing functions provides an efficient
way to make R code re-usable and modular, we should note that it is important
to ensure that functions only work in their intended use-cases. Checking
function argument values is related to the concept of *defensive programming*.
Defensive programming encourages us to frequently check conditions and return an
error if something is wrong. These checks are referred to as assertion
statements because we want to assert some condition is `TRUE` before proceeding.
They make it easier to debug problems because they give us a better idea of where the
errors originate.

#### Checking conditions with `stopifnot()`

Let's start by re-examining `fahr_to_kelvin()`, our function for converting
temperatures from Fahrenheit to Kelvin. It was defined like so:

```{r}
fahr_to_kelvin <- function(temp) {
  kelvin <- ((temp - 32) * (5 / 9)) + 273.15
  return(kelvin)
}
```

For this function to work as intended, the argument `temp` must be a `numeric`
value; otherwise, the mathematical procedure for converting between the two
temperature scales will not work. 

Let's see what happens if we try to use it incorrectly:

```{r error = TRUE}
fahr_to_kelvin("0 degrees")

```
We get an error, but unless you have been using R for a while, this error might not make much sense or, more importantly, tell you where and how to fix the problem.

To create a more informative error, we can use the function `stop()`. For example, since the argument `temp` must be a `numeric` vector, we could check for this condition with an `if` statement and produce an error if the condition was violated. We could augment our function above like so:

```{r}
fahr_to_kelvin <- function(temp) {
  
  # Check whether temp is numeric and produce and error if not.
  if (!is.numeric(temp)) {
    stop("temp must be a numeric vector.")
  }
  
  # Calculate the temperature in kelvin
  kelvin <- ((temp - 32) * (5 / 9)) + 273.15
  
  return(kelvin)
}
```

If we had multiple conditions or arguments to check, it would take many lines of code to check all of them. Luckily R provides the convenience function `stopifnot()`. We can list as many requirements that should evaluate to `TRUE`; `stopifnot()` produces an error if it finds one that is `FALSE`. Listing these conditions also serves a secondary purpose as extra documentation for the function.

Let's try out defensive programming with `stopifnot()` by adding assertions to
check the input to our function `fahr_to_kelvin()`.

We want to assert the following: `temp` is a numeric vector. We may do that like
so:

```{r}
fahr_to_kelvin <- function(temp) {
  
  # Check whether temp is numeric and produce and error if not.
  stopifnot(is.numeric(temp))
  
  # Calculate the temperature in kelvin
  kelvin <- ((temp - 32) * (5 / 9)) + 273.15
  
  return(kelvin)
}
```

It still works when given proper input.

```{r}
# freezing point of water
fahr_to_kelvin(temp = 32)
```

But fails instantly if given improper input. 

```{r error = TRUE}
# Metric is a factor instead of numeric
fahr_to_kelvin(temp = "32 degrees")
```
Notice that the error message is still informative, but we did not provide the text of the error message when we defined the `stopifnot()` statement. Use the `stop()` function if you want to provide a custom error message.


::: {.challenge}

Use defensive programming to ensure that our `kelvin_to_celsius()` function produces an error immediately if the argument `temp` is specified inappropriately.

<details><summary>**Solution:**</summary>

::: {.solution}

Extend our previous definition of the function by adding in an explicit call to `stopifnot()`. Since `fahr_to_celsius()` is a composition of two other functions, it makes the most sense to check before calling the other functions.

```{r}
fahr_to_celsius <- function(temp) {
  
  # Check whether temp is numeric and produce and error if not.
  stopifnot(is.numeric(temp))
  
  temp_k <- fahr_to_kelvin(temp)
  temp_c <- kelvin_to_celsius(temp_k)

  return(temp_c)
}
```

:::

</details>

:::

<br>

# Chapter `r .chp_num`. `r get_chpName(.chp_num, type.to = "nameLong")` {.tabset}

## Overview 

> MOTIVATOR

Brief description of the contents of this lesson. 

### What we will learn



In this lesson 
`r .get_LO(as.numeric(.chp_num), .LOtable, prefix = TRUE)`

#### Key Terms & Commands

* term 1
* term 2
* `function1()`


### Prerequisites

Describe any data sets or packages that learners need to download or install before proceeding.

```{r results = 'hide'}
# Read in a data file from the data folder included with the student workbook
dat <- read.csv("data/gapminder_data.csv")
```


## Lesson


```{r}
# This is an R code block that will execute any code inside and show the results.
5+3

```


### Section 1


::: {.challenge}
What should be the output for each of these commands?

```{r eval = FALSE}
log(exp(3 + 3)) 
e-1 + 5
```

<details><summary>**Solution:**</summary>

::: {.solution}

```{r echo = FALSE}
log(exp(3 + 3)) 
2e-1 + 5
```

:::

</details>

:::

<br>

### Section 2

Callouts are formatted in the style.css file.

::: {.callout-trick}

:::


::: {.callout-tip}

:::

::: {.callout-important}

:::

## Exercises

After completing these exercises, learners will be able to 
`r .get_LO(.chp, .CStable, prefix = TRUE, bullet = "1.")`


Number all exercises using the module number. Include starter code in the /exercises folder if appropriate.

**`r .chp_num`.1** 

**`r .chp_num`.2** 




Modify the `calc_monthly_avg()` function to return temperature values in fahrenheit or kelvin, based on an argument provided to the function.

Modify the calc_monthly_avg() function to return the max, min or mean temperature values, based on an argument provided to the function.




Modify the `calc_monthly_avg()` function from the [`r .get_chpName("functions", type.from = "chp")`](chp-functions.html) lesson so that the user can specify which sensors the average should be calculated from: "Upper" (corresponding to horizontal position 101 or 111), "Lower" (corresponding to horizontal position 102 or 112) or "Both". The default value should be "Both".

## Sources and Resources

This lesson was adapted from [@swc-reproducible-lesson](https://swcarpentry.github.io/r-novice-gapminder/) episodes 7 and 10  by Jes Coyle.

### Additional Resources

### Cited References

::: {#refs}
:::
