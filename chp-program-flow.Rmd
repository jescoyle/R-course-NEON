---
title:  
output:
  html_document:
    toc: false
bibliography: references.bib
nocite: |
  @NEON-surfwatertemp
---

```{r, include = FALSE, purl = FALSE}
# Functions and data
getwd()
source("src/setup.R")

# get chapter number based on name
.chp <- "program-flow"
.chp_num <- .get_chpNum("chp-program-flow", type = "fileName")
.chp_str <- ifelse(nchar(.chp_num) > 1, .chp_num, paste0("0", .chp_num))

# knitr options
source("src/knit-options.R")
.knitr_fig_path(paste0(.chp_str, "-"))

# Silently set seed for random number generation, so we don't have to explain it
set.seed(10)
```

# Chapter `r .chp_num`. `r .get_chpName(.chp_num, type.to = "nameLong")` {.tabset}

## Overview 

> Suppose you have temperature measurements collected over the course of a year from 100 different sensors, each saved in its own data file, and you want to summarize the daily temperature minima and maxima for each sensor, but only if the sensor did not malfunction. Wouldn't it be great if you had one code script that looks in a folder for the temperature sensor data files, detects whether the data are valid and if so, summarizes the data and saves this to an output file? 

This lesson will introduce you to a central idea in computer-programming- how to write flexible code that makes automated and repeated data-dependent decisions. The tools that we will use are common to most programming languages, even if the exact syntax varies. These fundamental elements of programming are called **conditionals** and **loops**.

### What we will learn

In this lesson 
`r .get_LO(.chp, .LOtable, prefix = TRUE)`


#### Key Terms & Commands

* if-then-else statements
* loops
* iteration
* boolean operators: `&` and `|`
* `if()`
* `else()`
* `ifelse()`
* `any()` and `all()`
* `for()`
* `while()`
* `print()`
* `paste()`
* `which()`


### Prerequisites

Before beginning this lesson you should have completed the lesson [`r .get_chpName("functions", type.from = "chp")`](chp-functions.html) and any prerequisites therein.

Before you begin:

1. Open the R-course-NEON-workbook RStudio project.
2. Create a new R script named `r paste0("lesson_", .chp_str, "_code.R")` in the lesson-code folder of the student workbook.
3. Whenever you see R code like this:

```{r eval = FALSE}
Type (or copy) this into your R script. Then run it in the Console.

```

4. Whenever you see a challenge like this:

:::{.challenge}

Try to solve the problem by writing R code into your script. Check your answer by clicking:

<details><summary>**Solution:**</summary>

::: {.solution}

```{r eval = FALSE}
The code that solves the challenge will appear here.
```

Along with an explanation.

:::

</details>

:::

<br>


4. Be sure to click **Save** often to save your work.

```{r results = 'hide'}
# Load ggplot2
library("ggplot2")

# Set theme options
# ggplot theme options
theme_set(theme_gray(base_size = 30))
update_geom_defaults("point", aes(size = 3))


# Read in a data file from the data folder included with the student workbook

```


## Lesson


program-flow	1	use conditional statements to make data-dependent decisions in R	learners will
program-flow	2	use loops to repeat things in R	learners will
program-flow	3	write expressions containing multiple logical statements in R	learners will

program-flow	1	execute if-else statements	use R to
program-flow	2	repeat steps using `for` and `while` loops	use R to
program-flow	3	evaluate expressions using `&` ('and') and `|` ('or')	use R to
program-flow	4	write checks on argument conditions within a function in R

In this lesson we are going to download and work with surface water temperature data  (DP1.20053/001)[https://data.neonscience.org/data-products/DP1.20053.001] from four NEON aquatic sites: Caribou Creek, Alaska (CARI), Martha Creek, Washington (MART), Teakettle Creek, California (TECR) and Sycamore Creek, Arizona (SYCA). You can see a map of these sites on the (NEON website)[https://www.neonscience.org/field-sites/explore-field-sites].

Recall from the lesson [`r .get_chpName("functions", type.from = "chp")`](chp-functions.html) that we can download data from NEON using the `loadByProduct()` function in the `neonUtilities` package. We need to specify the product ID number, sites and dates for which we want data and then type `y` when prompted to download the data at the command line.

```{r eval = FALSE}
library(neonUtilities)

# Define dates for download: June 1 - Oct 31, 2021
# but we need to start before June 1 to get the entire month of June
startdate <- "2021-05-31"
enddate <- "2021-10-31"

# Define the sites to download 
# TECR = Teakettle Creek, SYCA = Sycamore Creek
# MART = Martha Creek, CARI = Caribou Creek
sites <- c("TECR", "SYCA", "MART", "CARI") 

# Define the data product
dpID <- "DP1.20053.001"  # Surface water temperature

# Temperature in surface water
watertemp <- loadByProduct(dpID = dpID,
                           site = sites,
                           startdate = startdate,
                           enddate = enddate)

```
```{r include = FALSE}
# Load neonUtilities package
library(neonUtilities)

# Load previously downloaded object
#save(watertemp, file = "src/chp-program-flow_watertemp.RData")
load("src/chp-program-flow_watertemp.RData")
```

You should now have a new object named `watertemp` in the Environment panel. It should be a list with nine elements. Let's extract the list element of `watertemp` that contains the data and save it as a separate data frame.

```{r}
# Extract 30 min temperature averages from watertemp
# and save as a separate data frame
TSW_30min <- watertemp$TSW_30min

```

Now we have a data frame where each row summarizes temperature measurements over a 30 minute period from May - October, 2021 for the four sites from which we requested data (TECR, SYCA, MART, CARI).

The last thing we will do to get these data ready to work with is to convert the `startDateTime` column to a date-time class so that we can use it as an actual date. We will use the `ymd_hms()` function from the `lubridate()` package for this.

```{r}
# Load the lubridate package
library(lubridate)

# Convert startDateTime to a date-time class
TSW_30min$startDateTime <- ymd_hms(TSW_30min$startDateTime)

```
To get a quick summary of the data available, we can use the `table()` function to count the number of observations (e.g. rows) from each month and site. The code below uses the `with()` function to specify the dataframe that `table()` should use to find columns named `startDateTime` and `siteID`. 

```{r}
# Count the number of observations in each month and site
with(TSW_30min, table(months(startDateTime), siteID))

```
The `months()` function extracts the month from the `startDateTime` column as text. (`month()` would give the numeric month).


### Conditionals

A conditional statement executes different lines of code depending on whether or not a particular condition is true. This allows us to write code that performs different actions depending on the values contained in variables, ultimately defining the flow of a program.

There are several ways to control flow in R using conditionals. The most commonly used approaches are the constructs:

```{r, eval = FALSE}
# if
if (condition is true) {
  perform action
}

# if ... else
if (condition is true) {
  perform action
} else {  # that is, if the condition is false,
  perform alternative action
}
```

Say, for example, that we want the R console to print a message if a variable `x` has a particular value:

```{r}
x <- 8

if (x >= 10) {
  print("x is greater than or equal to 10")
}

x
```

The print statement does not appear in the console because x is not greater than 10. To print a different message for numbers less than 10, we can add an `else` statement.

```{r}
x <- 8

if (x >= 10) {
  print("x is greater than or equal to 10")
} else {
  print("x is less than 10")
}
```

You can also test multiple conditions by using `else if`.

```{r}
x <- 8

if (x >= 10) {
  print("x is greater than or equal to 10")
} else if (x > 5) {
  print("x is greater than 5, but less than 10")
} else {
  print("x is less than 5")
}
```

::: {.challenge}
Change the value of `x` to `3` (`x <- 3`), then re-run the conditional statement above to verify that this works.

What happens when you change the value of `x` to be missing (`NA`)?

:::


**Important:** when R evaluates the condition inside `if()` statements, it is looking for a logical data type, i.e., `TRUE` or `FALSE`. If the value inside the `if()` statement is anything but `TRUE` or `FALSE` (e.g. `NA`) the console will print an error message.




::: {.challenge}

The `finalQF` column in `TSW_30min` indicates whether the data are valid to use. It will be `0` when the data are good and `1` when the data could be erroneous.

Use an `if()` statement to print a message that says whether there are any erroneous data points in `TSW_30min`.

<details><summary>**Solution:**</summary>

::: {.solution}

There are lots of ways to solve this problem. Here's one way to solve this problem using commands you already know.

```{r eval = FALSE}
# First we subset TSW_30min to only contain rows where finalQF is 1
bad_data <- subset(TSW_30min, finalQF == 1)

# Next we count the number of rows
N_bad <- nrow(bad_data)

# Then we use a conditional to print a message
# depending on the number of rows of bad data
if (N_bad > 0) {
 print("This data contains erroneous measurements.") 
}


```

:::

</details>

:::

<br>


When you tried the challenge above, did you try something like this and get a warning message?

```{r}
if (TSW_30min$finalQF == 1) {
  print("This data contains erroneous measurements.")
}
```

The `if()` function only accepts singular (of length 1) inputs, and therefore returns an error when you use it with a vector. The `if()` function will still run, but will only evaluate the condition in the first element of the vector. Therefore, to use the `if()` function, you need to make sure your input is
singular (of length 1).

To determine whether some or all of the elements of a vector are equal to a particular value, you can use the `any()` and `all()` functions. 

`any()` tests whether any of the elements in a vector are `TRUE` and returns a single value of `TRUE` if at least one element is `TRUE`. In contrast the `all()` function tests whether all of the elements of a vector are `TRUE` and only returns the value `TRUE` if this is the case.

```{r}
all_F <- c(FALSE, FALSE, FALSE)
some_T <- c(TRUE, FALSE, TRUE)
all_T <- c(TRUE, TRUE, TRUE)

any(all_F)
any(some_T)
any(all_T)

all(some_T)
all(all_T)
```

Here is a more efficient way to solve this challenge above using the `any()` function. 

```{r}
if (any(TSW_30min$finalQF ==  1)) {
 print("This data contains erroneous measurements.") 
}
```



:::{.callout-tip}

Use the `ifelse()` function on vectors.

`R` accepts both `if()` and `else if()` statements structured as outlined above, but also statements using `R`'s built-in `ifelse()` function. This function accepts both singular and vector inputs and is structured as follows:

```{r, eval = FALSE}
# ifelse function
ifelse(condition is true, perform action, perform alternative action)

```

where the first argument is the condition or a set of conditions to be met, the second argument is the statement that is evaluated when the condition is `TRUE`, and the third statement  is the statement that is evaluated when the condition is `FALSE`.

```{r}
y <- -3
ifelse(y < 0, "y is a negative number", "y is not a negative number")

```

```{r}
y <- -2:3

ifelse(y < 0, "y is a negative number", "y is not a negative number")

```
The `ifelse()` function is particularly useful for creating a factor from numeric data or combining levels of a factor.

For example, we could create a factor in the `TSW_30min` data that identifies whether a site is in Alaska or the contiguous US (the "lower 48"):

```{r}
# Create a factor that identifies whether a site is in Alaska
# e.g. the CARI site
TSW_30min$siteLocation <- factor(ifelse(TSW_30min$siteID == "CARI", "AK", "lower48"))

```

::: {.challenge}

Create a new variable in `TSW_30min` named `frozen` that has the value `"above 0"` if the minimum temperature for an observation is greater than `0` and "below 0" if the mean temperature is less than or equal to `0`.

Hint: use the `ifelse()` function on the `surfWaterTempMinimum` column.

<details><summary>**Solution:**</summary>

::: {.solution}

```{r}
TSW_30min$frozen <- ifelse(TSW_30min$surfWaterTempMinimum > 0, "above 0", "below 0")

```

We can use the `table()` function to see how many times each of these conditions occurred in these data.

```{r}
table(TSW_30min$frozen)
```

:::

</details>

:::

<br>





### Loops

**Loops** are a fundamental element of programming that allow you to repeat a set of actions multiple times. There are two main types:

* a `for` loop **iterates** over a set of elements, repeating the set of actions once for each element in the order that they are provided.
* a `while` loop repeats a set of actions over and over until a specific condition is met.

#### `for()` loops

The basic structure of a `for()` loop is:

```{r, eval = FALSE}
for (iterator in set of values) {
  do a thing
}
```

For example:

```{r}
for (i in 1:10) {
  print(i)
}
```

The `1:10` creates a vector of the integers `1` through `10`. Each time through the loop, the value of the object `i` will take on the next value in this vector. You can iterate over any other vector using any variable name:

```{r}
mypets <- c("cat", "dog", "bird", "cat")

for (animal in mypets) {
  print(animal)
}

```

We can use a `for()` loop nested within another `for()` loop to iterate over two things at
once.

```{r}
for (i in 1:5) {
  for (j in c('a', 'b', 'c', 'd', 'e')) {
    
    # The `paste()` function creates a character vector by 
    # concatenating the vectors `i` and `j`
    print(paste(i,j))
  }
}
```


We notice in the output that when the first index (`i`) is set to 1, the second index (`j`) iterates through its full set of indices. Once the indices of `j` have been iterated through, then `i` is incremented. This process continues until the last index has been used for each `for()` loop.

Rather than printing the results, we could write the loop output to an output object, in this case a matrix.

```{r}
output_matrix <- matrix()
for (i in 1:5) {
  for (j in c('a', 'b', 'c', 'd', 'e')) {
    # save the result to a temporary variable temp_output
    temp_output <- paste(i, j)
    
    # add temp_output to the end of temp_row
    temp_row <- c(temp_row, temp_output)
  }
  
  # add temp_row onto the bottom of output_matrix
  output_matrix <- rbind(output_matrix, temp_row)
}
output_vector
```

This approach can be useful, but 'growing your results' (building the result object incrementally) is computationally inefficient, so avoid it when you are iterating through a lot of values.

:::{.callout-tip}
Don't grow your results

One of the biggest things that trips up novices and experienced R users alike, is building a results object (vector, list, matrix, data frame) as your for loop progresses. Computers are very bad at handling this, so your calculations can very quickly slow to a crawl. It's much better to define an empty results object before hand of appropriate dimensions, rather than initializing an empty object without dimensions.

So if you know the end result will be stored in a matrix like above, create an empty matrix with 5 row and 5 columns, then at each iteration store the results in the appropriate location.

{: .callout}

A better way is to define your (empty) output object before filling in the values.
For this example, it looks more involved, but is still more efficient.

```{r}
output_matrix <- matrix(nrow = 5, ncol = 5)
j_vector <- c('a', 'b', 'c', 'd', 'e')
for (i in 1:5) {
  for (j in 1:5) {
    temp_j_value <- j_vector[j]
    temp_output <- paste(i, temp_j_value)
    output_matrix[i, j] <- temp_output
  }
}

output_matrix
```

In general, the advice of many `R` users would be to learn about `for()` loops, but to avoid using `for()` loops unless the order of iteration is important: i.e. the calculation at each iteration depends on the results of previous iterations. If the order of iteration is not important, then you should try to use **vectorization** (see lessons [`r .get_chpName("functions", type.from = "chp")`](chp-functions.html) and [`r .get_chpName("tidyverse", type.from = "chp")`](chp-tidyverse.html).



::: {.challenge}

In the lesson [`r .get_chpName("functions", type.from = "chp")`](chp-functions.html) we wrote a function that calculate the average 

It looks like this (and you should have saved it in a script called `functions.R` in the `src` folder.

```{r}
# A function that calculates average monthly temperature
# for each sensor at a NEON site from a dataframe of temperature
# measurements.
# Arguments:
#   dat = a dataframe containing the columns: 
#         surfWaterTempMean, startDateTime, siteID, finalQF
#   site = the NEON site code for the site of interest
#   month = the month to calculate average temperature over
#   na.rm = indicates whether NA values should be removed prior to calculation
calc_monthly_avg <- function(dat, site, month, na.rm = TRUE) {
  
  # Remove data that did not pass quality control
  # keep finalQF == 0
  keep_dat <- subset(dat, finalQF == 0)
  
  # Subset the data frame to only contain observations from site
  keep_dat <- subset(keep_dat, siteID == site)
  
  # Subset the data frame to only contain observations from month
  # convert character to date
  keep_dat$startDateTime <- lubridate::ymd_hms(keep_dat$startDateTime) 
  
  # extract month as a numeric value
  keep_dat$startMonth <- lubridate::month(keep_dat$startDateTime)
  
  # subset based on month
  keep_dat <- subset(keep_dat, startMonth == month)
  
  # Calculate the average of the surfWaterTempMean column
  # use the na.rm value provided by the user of the function
  vals <- mean(keep_dat$surfWaterTempMean, na.rm = na.rm)
  
  # Return the calculated value
  return(vals)
}
```

Load this function into your current R session by either running the code above or sourcing the `functions.R` script:

```{r eval = FALSE}
source("src/functions.R")
```

```{r include = FALSE}
source("src/functions_chp-functions.R")
```

Using this function, write a loop that calculates the average monthly temperature at the Teakettle Creek site (`siteID == "TECR"`) in each month in the `TWS_30min` data.

The loop should save the output to a vector.


<details><summary>**Solution:**</summary>

::: {.solution}

```{r}
# Define vector of months to iterate over
# and save the length of this vector
use_months <- 6:10
N_months <- length(use_months)

# Define an empty vector for saving the data
# that is the same length as use_months
mean_temp <- rep(NA, N_months)

# Loop across months
for (i in 1:N_months) {
  
  # Define the month for this iteration
  this_month <- use_months[i]
    
  # Calculate monthly mean temp
  # and save into the vector
  mean_temp[i] <- calc_monthly_avg(dat = TSW_30min, 
                                site = "TECR",
                                month = this_month) 
  
}
 

# Print the output
mean_temp

```

:::

</details>

:::

<br>




::: {.challenge}

Update your solution to the prior challenge to write a set of nested loops that calculate the average water temperature for each month at each site in `TSW_30min`. The loop should save the output to a matrix.

<details><summary>**Solution:**</summary>

::: {.solution}

```{r}
# Define vector of months to iterate over
# and save the length of this vector
use_months <- 6:10
N_months <- length(use_months)

# Define vector of sites to iterate over
# and save the length of this vector
use_sites <- unique(TSW_30min$siteID)
N_sites <- length(use_sites)

# Define a matrix for saving values:
# months will be the rows and sitess with be the columns
mean_temp <- matrix(NA, nrow = N_months, ncol = N_sites)

# Loop across months
for (i in 1:N_months) {
  
  # Define the month for this iteration
  this_month <- use_months[i]
 
  # Loop across sites
  for (j in 1:N_sites) {
    
    # Define the site for this iteration
    this_site <- use_sites[j]
    
    # Calculate monthly mean temp
    # and store in the matrix
    mean_temp[i, j] <- calc_monthly_avg(dat = TSW_30min, 
                     site = this_site,
                     month = this_month) 
    
  }
  
}

# Print the output
mean_temp

```
After the calculation in the loop, we could make the output more informative by assigning column or row names:

```{r}
colnames(mean_temp) <- use_sites
rownames(mean_temp) <- use_months

mean_temp

```

Or, by converting it to a dataframe with a column for site.

```{r}
mean_temp <- data.frame(month = use_months, mean_temp)
mean_temp
```

:::

</details>

:::

<br>




#### `while()` loops

Sometimes you will find yourself needing to repeat an operation as long as a certain condition is met. You can do this with a `while()` loop.

```{r, eval=FALSE}
while (this condition is true) {
   do a thing
}
```

Here is and example of a `while` loop that adds up the integers until it reaches a sum that is greater than or equal to 100.

```{r}
# Define the initial condition:
i <- 1
total <- i

# Repeat the loop while the value of total < 100.
while (total < 100) {
  
  # Increment the integer by 1 and add to the total
  i <- i + 1
  total <- total + i
  
}

# print the total and value of i when the loop stopped
total
i

```


`while()` loops will not always be appropriate. You have to be particularly careful that you don't end up stuck in an infinite loop because your condition is always met and hence the while statement never terminates.



::: {.challenge}

Write a `while` loop that prints out the difference between the maximum and minimum temperature values for each row of `TSW_30min` until the temperature difference exceeds 5 degrees. This means that temperature fluctuated more than 5 degrees in that 30 minute time period. Your loop should also print out the row number.

<details><summary>**Solution:**</summary>

::: {.solution}

```{r eval = FALSE}
# Start at row 1
i <- 1

# Calculate the temperature difference in row i
temp_diff <- TSW_30min[i, "surfWaterTempMaximum"] - TSW_30min[i, "surfWaterTempMinimum"]

# Repeat the loop until the difference is greater than 5
while(temp_diff <= 5){
  
  # Print the temperature difference and the row number
  print(paste("row:", i, "difference:", temp_diff))
  
  # Increment the row by 1 and recalculate the difference
  i <- i + 1
  temp_diff <- TSW_30min[i, "surfWaterTempMaximum"] - TSW_30min[i, "surfWaterTempMinimum"]
  
}


```


:::

</details>

:::

<br>

While loops are rarely the best solution to a problem. Here is a more efficient way to identify the first time a row exceeds a five degree difference between the maximum and minimum temperature values.

To do this we use the `which()` function. This function gives the indices of a boolean vector that are true.

```{r}
which(c(TRUE, TRUE, FALSE, TRUE))

which(20:30 > 27)

which(c("a", "b", "c", "d") %in% c("c", "a"))

```
We can use `which()` to find the first index of a row with a temperature difference greater than 5 degrees, then calculate the temperature difference from all rows less than this index.

```{r}
# Calculate the difference in temperatures
tempdiff <- with(TSW_30min, surfWaterTempMaximum - surfWaterTempMinimum)

# Which rows of TSW_30min have a temperature range >= 5?
gt5 <- which(tempdiff >= 5)

# What is the smallest index in gt5?
first_gt5 <- min(gt5)

# Return the temperature difference for all rows preceding first_gt5
tempdiff[1:(first_gt5-1)]
```
You could even return this result as a dataframe:

```{r}
data.frame(row = 1:(first_gt5-1), 
           temp_difference = tempdiff[1:(first_gt5-1)])

```




### Putting it all together

We're going to write a script that plots the average monthly temperature for each NEON site in `TSW_30min`, but only if less than 10% of the data are erroneous. Our script will automatically save each plot to a file in an output folder.

We should start by creating a new R script with a descriptive name and saving it in the `src` folder. Create a new R script in your `src` folder named `plot_monthly_temp.R`. In this script use comments to outlines what we are trying to do:

```{r eval= FALSE}

# Define vector of months in TSW_30min

# Define vector of sites in TSW_30min

# Define a matrix for saving values


# Loop through each month in TSW_30min
for (     ) {
  
  # Loop through each site in TSW_30 min
  for (    ) {

      # Determine the fraction of erroneous data
      # finalQF != 0
  
      # If the fraction is < 0.1
      # Calculate the monthly mean temperature
    
      # Save values into the matrix

  
  }
  
}

# Convert the matrix into a dataframe

# For each site
# Plot monthly mean temperature versus month

# Save the plot to a file in the results folder


```

We have already done most of this. The code below aggregates code we have already written in the lesson above.

```{r eval= FALSE}
# Source our functions script that contains the 
# calc_monthly_avg() function
source("src/functions.R")

# Define vector of months in TSW_30min
use_months <- unique(month(TSW_30min$startDateTime))
N_months <- length(use_months)

# Define vector of sites in TSW_30min
use_sites <- unique(TSW_30min$siteID)
N_sites <- length(use_sites)

# Define a matrix for saving values:
# months will be the rows and sitess with be the columns
mean_temp <- matrix(NA, nrow = N_months, ncol = N_sites)

# Loop through each month in TSW_30min
for (i in 1:N_months) {
  
  # Define this month
  this_month <- use_months[i]
  
  # Loop through each site in TSW_30 min
  for (j in 1:N_sites) {
    
      # Define this site
      this_site <- use_sites[j]
    
      # Determine the fraction of erroneous data
      # finalQF != 0
      
      
  
      # If the fraction is < 0.1
      # Calculate the monthly mean temperature
      this_temp <- calc_monthly_avg(dat = TSW_30min, 
                     site = this_site,
                     month = this_month) 
      
    
      # Save values into the matrix
      mean_temp[i, j] <- this_temp
    
  }
  
}

# Convert the matrix into a dataframe

# For each site
# Plot monthly mean temperature versus month

# Save the plot to a file in the results folder

```

All we need to do is determine the percentage of erroneous data in each month and site. There are several approaches to doing this:

1. We could subset `TSW_30min` inside the two loops and then look for erroneous data in each subset.
2. We could tabulate the number of erroneous data points in each month and site before using the loop, then select the appropriate element from this table inside the loop.

We should select the option that requires the least number of computations. This would be option 2, because it doesn't require subsetting the data `r N_months*N_sites` times (`N_months x N_sites`). Let's see how this works:

```{r}
# Tabulate TSW_30min by month, site and value of finalQF
QF_tab <- with(TSW_30min, table(month(startDateTime), siteID, finalQF))

dim(QF_tab)
dimnames(QF_tab)
```
We can see that QF_tab is a 3-dimensional array because we tabulated by 3 variables. The first dimension is the month, the second dimension is the site and the third dimension is the value of `finalQF`. We can see the values stores in the array here:

```{r}
QF_tab
```
Thus if we specify an index in the third dimension we can select either the number of good or erroneous data points:

```{r}
# Number of good data points
QF_tab[ , , 1]

# Number of erroneous data points
QF_tab[ , , 2]

```


::: {.challenge}

Use mathematical operations on QF_tab to make a table containing the fraction of erroneous data points for each site and month ( = num erroneous points / total number of points).


<details><summary>**Solution:**</summary>

::: {.solution}

```{r}
# Calculate the fraction of erroneous data points
QF_frac <- QF_tab[ , , 2] / (QF_tab[ , , 1] + QF_tab[ , , 2])

```

:::

</details>

:::

<br>

Now if we calculate this table containing the fraction of erroneous data points before the loop, we can select elements from it within the loop to decide whether to proceed with calculating mean temperature in a given month and site.

We need to be careful to use names (e.g. "6") rather than numeric indices to select the row and column from `QF_frac`, since the order of rows and columns is not necessarily the same as the order in `use_months` and `use_sites`.

```{r}
QF_frac["6", "CARI"]

```
That means that we need to convert `use_month` to a character before using it to select a row from `QF_frac`. Otherwise, this will happen:

```{r}
QF_frac[6, "CARI"]
```

Here's our code so far:

```{r}
# Source our functions script that contains the 
# calc_monthly_avg() function
source("src/functions.R")

# Define vector of months in TSW_30min
use_months <- unique(month(TSW_30min$startDateTime))
N_months <- length(use_months)

# Define vector of sites in TSW_30min
use_sites <- unique(TSW_30min$siteID)
N_sites <- length(use_sites)

# Define a matrix for saving values:
# months will be the rows and sitess with be the columns
mean_temp <- matrix(NA, nrow = N_months, ncol = N_sites)

# Tabulate TSW_30min by month, site and value of finalQF
#  and calculate the fraction of erroneous data points
QF_tab <- with(TSW_30min, table(month(startDateTime), siteID, finalQF))
QF_frac <- QF_tab[ , , 2] / (QF_tab[ , , 1] + QF_tab[ , , 2])

# Loop through each month in TSW_30min
for (i in 1:N_months) {
  
  # Define this month
  this_month <- use_months[i]
  
  # Loop through each site in TSW_30 min
  for (j in 1:N_sites) {
    
      # Define this site
      this_site <- use_sites[j]
    
      # Determine the fraction of erroneous data
      this_frac <- QF_frac[as.character(this_month), this_site]
      
      
      # If the fraction is < 0.1
      if (this_frac < 0.1) {
        
        # Calculate the monthly mean temperature
        this_temp <- calc_monthly_avg(dat = TSW_30min, 
                       site = this_site,
                       month = this_month) 
      
        # Save values into the matrix
        mean_temp[i, j] <- this_temp
        
      } # else the NA value will stay in the matrix
 
  }
  
}

# Convert the matrix into a dataframe

# For each site
# Plot monthly mean temperature versus month

# Save the plot to a file in the results folder
```

This code will run, but isn't plotting a figure yet. We can check the values calculated in the loop for mean temperature and wee that the ones where `QF_frac` were greater than `0.1` remained as missing (`NA`).

```{r}
mean_temp

QF_frac
```

The last step is to create a plot and save it to a file. We will use the `plot()` function in base R for this.

::: {.challenge}

Fill in the three blanks in the code below so that it will execute properly.

```{r}
# Convert the matrix into a dataframe
colnames(mean_temp) <- use_sites
mean_temp_df <- data.frame(month = use_months, mean_temp)

# For each site
for (this_site in use_sites) {
  
  # Define the file name for this plot using the site in this iteration
  this_filename <- paste("results/mean_monthly_temp_", ___________,".pdf", sep = "")
  
  # Open a new graphics device to save the plot
  pdf(this_filename, height = 5, width = 4)
  
  # Plot monthly mean temperature versus month
  plot(x = ___________, 
       y = mean_temp_df[, _________],
       xlab = "Month", 
       ylab = expression("Mean temperature"~(degree*C)))
  
  # Close the graphics device (save the plot file)
  dev.off()
  
}
```

Once you solve this challenge, append this code to the end of your script.

:::

<br>


<details><summary>Click here to show what your final script should look like.</summary>

```{r eval = FALSE}
# Source our functions script that contains the 
# calc_monthly_avg() function
source("src/functions.R")

# Define vector of months in TSW_30min
use_months <- unique(month(TSW_30min$startDateTime))
N_months <- length(use_months)

# Define vector of sites in TSW_30min
use_sites <- unique(TSW_30min$siteID)
N_sites <- length(use_sites)

# Define a matrix for saving values:
# months will be the rows and sitess with be the columns
mean_temp <- matrix(NA, nrow = N_months, ncol = N_sites)

# Tabulate TSW_30min by month, site and value of finalQF
#  and calculate the fraction of erroneous data points
QF_tab <- with(TSW_30min, table(month(startDateTime), siteID, finalQF))
QF_frac <- QF_tab[ , , 2] / (QF_tab[ , , 1] + QF_tab[ , , 2])

# Loop through each month in TSW_30min
for (i in 1:N_months) {
  
  # Define this month
  this_month <- use_months[i]
  
  # Loop through each site in TSW_30 min
  for (j in 1:N_sites) {
    
      # Define this site
      this_site <- use_sites[j]
    
      # Determine the fraction of erroneous data
      this_frac <- QF_frac[as.character(this_month), this_site]
      
      
      # If the fraction is < 0.1
      if (this_frac < 0.1) {
        
        # Calculate the monthly mean temperature
        this_temp <- calc_monthly_avg(dat = TSW_30min, 
                       site = this_site,
                       month = this_month) 
      
        # Save values into the matrix
        mean_temp[i, j] <- this_temp
        
      } # else the NA value will stay in the matrix
 
  }
  
}

# Convert the matrix into a dataframe
colnames(mean_temp) <- use_sites
mean_temp_df <- data.frame(month = use_months, mean_temp)

# For each site
for (this_site in use_sites) {
  
  # Define the file name for this plot
  this_filename <- paste("results/mean_monthly_temp_", this_site,".pdf", sep = "")
  
  # Open a new graphics device to save the plot
  pdf(this_filename, height = 5, width = 4)
  
  # Plot monthly mean temperature versus month
  plot(x = mean_temp_df$month, 
       y = mean_temp_df[, this_site],
       xlab = "Month", 
       ylab = expression("Mean temperature"~(degree*C)))
  
  # Close the graphics device (save the plot file)
  dev.off()
  
}

```

</details>



## Exercises

After completing these exercises, learners will be able to 
`r .get_LO(.chp, .CStable, prefix = TRUE, bullet = "1.")`


Number all exercises using the module number. Include starter code in the /exercises folder if appropriate.

**`r .chp_num`.1** 

**`r .chp_num`.2** 




Modify the `calc_monthly_avg()` function to return temperature values in fahrenheit or kelvin, based on an argument provided to the function.

Modify the calc_monthly_avg() function to return the max, min or mean temperature values, based on an argument provided to the function.




Modify the `calc_monthly_avg()` function from the [`r .get_chpName("functions", type.from = "chp")`](chp-functions.html) lesson so that the user can specify which sensors the average should be calculated from: "Upper" (corresponding to horizontal position 101 or 111), "Lower" (corresponding to horizontal position 102 or 112) or "Both". The default value should be "Both".

## Sources and Resources

This lesson was adapted from [@swc-reproducible-lesson](https://swcarpentry.github.io/r-novice-gapminder/) episodes 7 and 10  by Jes Coyle.

### Additional Resources

### Cited References

::: {#refs}
:::


Callouts are formatted in the style.css file.

::: {.callout-trick}

:::


::: {.callout-tip}

:::

::: {.callout-important}

:::
